package helpers

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"time"

	"github.com/orris-inc/orris/internal/domain/user"
	"github.com/orris-inc/orris/internal/shared/authorization"
	"github.com/orris-inc/orris/internal/shared/logger"
)

// DeviceInfo encapsulates device-related information for session creation
type DeviceInfo struct {
	DeviceName string
	DeviceType string
	IPAddress  string
	UserAgent  string
}

// SessionWithTokens represents a created session with its associated tokens
type SessionWithTokens struct {
	Session      *user.Session
	AccessToken  string
	RefreshToken string
	ExpiresIn    int64
}

// AuthHelper provides common authentication helper methods
type AuthHelper struct {
	userRepo    user.Repository
	sessionRepo user.SessionRepository
	logger      logger.Interface
}

// NewAuthHelper creates a new AuthHelper instance
func NewAuthHelper(
	userRepo user.Repository,
	sessionRepo user.SessionRepository,
	logger logger.Interface,
) *AuthHelper {
	return &AuthHelper{
		userRepo:    userRepo,
		sessionRepo: sessionRepo,
		logger:      logger,
	}
}

// IsFirstUser checks if this is the first user in the system
// First user is automatically granted admin privileges
func (h *AuthHelper) IsFirstUser(ctx context.Context) (bool, error) {
	filter := user.ListFilter{Page: 1, PageSize: 1}
	_, total, err := h.userRepo.List(ctx, filter)
	if err != nil {
		return false, fmt.Errorf("failed to count users: %w", err)
	}
	return total == 1, nil
}

// HashToken generates SHA256 hash of a token for secure storage
func (h *AuthHelper) HashToken(token string) string {
	hash := sha256.Sum256([]byte(token))
	return hex.EncodeToString(hash[:])
}

// CreateSessionWithTokens creates a new session with JWT tokens for a user
// This method encapsulates the complete workflow of:
// 1. Creating a new session
// 2. Hashing and storing tokens
// 3. Persisting session to database
// Note: JWT tokens should be generated by the caller using the session ID after session creation
func (h *AuthHelper) CreateSessionWithTokens(
	userID uint,
	deviceInfo DeviceInfo,
	sessionDuration time.Duration,
	accessToken string,
	refreshToken string,
	expiresIn int64,
) (*SessionWithTokens, error) {
	// Step 1: Create new session domain object
	expiresAt := time.Now().Add(sessionDuration)
	session, err := user.NewSession(
		userID,
		deviceInfo.DeviceName,
		deviceInfo.DeviceType,
		deviceInfo.IPAddress,
		deviceInfo.UserAgent,
		expiresAt,
	)
	if err != nil {
		h.logger.Errorw("failed to create session", "error", err, "user_id", userID)
		return nil, fmt.Errorf("failed to create session: %w", err)
	}

	// Step 2: Hash tokens for secure storage
	session.TokenHash = h.HashToken(accessToken)
	session.RefreshTokenHash = h.HashToken(refreshToken)

	// Step 3: Persist session to database
	if err := h.sessionRepo.Create(session); err != nil {
		h.logger.Errorw("failed to create session in database", "error", err, "user_id", userID, "session_id", session.ID)
		return nil, fmt.Errorf("failed to create session: %w", err)
	}

	h.logger.Infow("session created successfully", "user_id", userID, "session_id", session.ID)

	return &SessionWithTokens{
		Session:      session,
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
		ExpiresIn:    expiresIn,
	}, nil
}

// CreateAndSaveSessionWithTokens creates session, generates tokens, and saves everything
// This is a convenience method that handles the full workflow including JWT generation
// It accepts a token generator function to avoid dependency issues
func (h *AuthHelper) CreateAndSaveSessionWithTokens(
	userID uint,
	userUUID string,
	deviceInfo DeviceInfo,
	sessionDuration time.Duration,
	generateTokens func(userUUID string, sessionID string) (accessToken, refreshToken string, expiresIn int64, err error),
) (*SessionWithTokens, error) {
	// Step 1: Create new session domain object
	expiresAt := time.Now().Add(sessionDuration)
	session, err := user.NewSession(
		userID,
		deviceInfo.DeviceName,
		deviceInfo.DeviceType,
		deviceInfo.IPAddress,
		deviceInfo.UserAgent,
		expiresAt,
	)
	if err != nil {
		h.logger.Errorw("failed to create session", "error", err, "user_id", userID)
		return nil, fmt.Errorf("failed to create session: %w", err)
	}

	// Step 2: Generate JWT tokens using the user UUID and session ID
	accessToken, refreshToken, expiresIn, err := generateTokens(userUUID, session.ID)
	if err != nil {
		h.logger.Errorw("failed to generate JWT tokens", "error", err, "user_id", userID, "session_id", session.ID)
		return nil, fmt.Errorf("failed to generate tokens: %w", err)
	}

	// Step 3: Hash tokens for secure storage
	session.TokenHash = h.HashToken(accessToken)
	session.RefreshTokenHash = h.HashToken(refreshToken)

	// Step 4: Persist session to database
	if err := h.sessionRepo.Create(session); err != nil {
		h.logger.Errorw("failed to create session in database", "error", err, "user_id", userID, "session_id", session.ID)
		return nil, fmt.Errorf("failed to create session: %w", err)
	}

	h.logger.Infow("session created successfully", "user_id", userID, "session_id", session.ID)

	return &SessionWithTokens{
		Session:      session,
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
		ExpiresIn:    expiresIn,
	}, nil
}

// GrantAdminToFirstUserIfNeeded checks if this is the first user and grants admin role
// Returns (wasGranted, error) where wasGranted indicates if admin role was assigned
func (h *AuthHelper) GrantAdminToFirstUserIfNeeded(ctx context.Context, u *user.User) (bool, error) {
	if u == nil {
		return false, fmt.Errorf("user cannot be nil")
	}

	isFirstUser, err := h.IsFirstUser(ctx)
	if err != nil {
		h.logger.Errorw("failed to check if first user", "error", err, "user_id", u.ID())
		return false, fmt.Errorf("failed to check if first user: %w", err)
	}

	if !isFirstUser {
		return false, nil
	}

	h.logger.Infow("first user detected, should grant admin role", "user_id", u.ID())
	return true, nil
}

// GrantAdminAndSave grants admin role to first user and saves to database
func (h *AuthHelper) GrantAdminAndSave(ctx context.Context, u *user.User) error {
	if u == nil {
		return fmt.Errorf("user cannot be nil")
	}

	isFirstUser, err := h.IsFirstUser(ctx)
	if err != nil {
		h.logger.Errorw("failed to check if first user", "error", err, "user_id", u.ID())
		return fmt.Errorf("failed to check if first user: %w", err)
	}

	if !isFirstUser {
		return nil
	}

	u.SetRole(authorization.RoleAdmin)

	// Use unified save method (non-critical since user is already created)
	result, _ := h.SaveUserWithLogging(ctx, u, false, "grant admin role to first user")
	if !result.Success {
		return result.Error
	}

	return nil
}

// SetSessionTokens sets both access token hash and refresh token hash for a session
// This is typically used during login flows where a new session is created with both tokens
func (h *AuthHelper) SetSessionTokens(session *user.Session, accessToken, refreshToken string) {
	session.TokenHash = h.HashToken(accessToken)
	session.RefreshTokenHash = h.HashToken(refreshToken)
}

// UpdateSessionAccessToken updates only the access token hash for a session
// This is used during token refresh flow where only the access token is regenerated
// while the refresh token remains the same
func (h *AuthHelper) UpdateSessionAccessToken(session *user.Session, accessToken string) {
	session.TokenHash = h.HashToken(accessToken)
}

// ============================================================================
// User Validation Methods
// ============================================================================

// UserValidationError represents a structured validation error with context
type UserValidationError struct {
	Code    string // Error code for programmatic handling
	Message string // Human-readable error message
	Field   string // Optional field that caused the error
}

// Error implements the error interface
func (e *UserValidationError) Error() string {
	return e.Message
}

// NewUserValidationError creates a new UserValidationError
func NewUserValidationError(code, message, field string) *UserValidationError {
	return &UserValidationError{
		Code:    code,
		Message: message,
		Field:   field,
	}
}

// Common validation error codes
const (
	ErrCodeAccountLocked       = "ACCOUNT_LOCKED"
	ErrCodeAccountInactive     = "ACCOUNT_INACTIVE"
	ErrCodePasswordUnavailable = "PASSWORD_UNAVAILABLE"
	ErrCodeInvalidCredentials  = "INVALID_CREDENTIALS"
	ErrCodeUserNotFound        = "USER_NOT_FOUND"
)

// ValidateUserCanLogin validates that a user can perform password-based login
// This method performs comprehensive checks required for password authentication:
// 1. User exists
// 2. Account is not locked (due to failed login attempts)
// 3. Password authentication is available
// 4. Account is in active status
func (h *AuthHelper) ValidateUserCanLogin(u *user.User) *UserValidationError {
	if u == nil {
		return NewUserValidationError(ErrCodeUserNotFound, "user not found", "user")
	}

	if u.IsLocked() {
		h.logger.Warnw("login attempt on locked account", "user_id", u.ID())
		return NewUserValidationError(
			ErrCodeAccountLocked,
			"account is temporarily locked due to too many failed login attempts",
			"account",
		)
	}

	if !u.HasPassword() {
		h.logger.Warnw("login attempt on account without password", "user_id", u.ID())
		return NewUserValidationError(
			ErrCodePasswordUnavailable,
			"password login not available for this account",
			"password",
		)
	}

	if !u.CanPerformActions() {
		h.logger.Warnw("login attempt on inactive account", "user_id", u.ID(), "status", u.Status())
		return NewUserValidationError(
			ErrCodeAccountInactive,
			"account is not active",
			"status",
		)
	}

	return nil
}

// ValidateUserCanPerformAction validates that a user can perform general actions
// This is a lighter validation suitable for OAuth login and other operations
// It only checks:
// 1. User exists
// 2. Account is in active status
func (h *AuthHelper) ValidateUserCanPerformAction(u *user.User) *UserValidationError {
	if u == nil {
		return NewUserValidationError(ErrCodeUserNotFound, "user not found", "user")
	}

	if !u.CanPerformActions() {
		h.logger.Warnw("action attempt on inactive account", "user_id", u.ID(), "status", u.Status())
		return NewUserValidationError(
			ErrCodeAccountInactive,
			"account is not active",
			"status",
		)
	}

	return nil
}

// ============================================================================
// User Save Operations
// ============================================================================

// SaveUserResult represents the result of a user save operation
type SaveUserResult struct {
	Success bool
	Error   error
}

// SaveUserWithLogging saves user with unified error handling and logging
// Parameters:
//   - isCritical: true = save failure returns error, false = save failure only logs warning
//   - operation: description for logging context
func (h *AuthHelper) SaveUserWithLogging(
	ctx context.Context,
	u *user.User,
	isCritical bool,
	operation string,
) (*SaveUserResult, error) {
	if u == nil {
		err := fmt.Errorf("user cannot be nil")
		h.logger.Errorw("save user failed: nil user", "operation", operation)
		if isCritical {
			return &SaveUserResult{Success: false, Error: err}, err
		}
		return &SaveUserResult{Success: false, Error: err}, nil
	}

	if err := h.userRepo.Update(ctx, u); err != nil {
		h.logger.Errorw(
			"failed to save user",
			"operation", operation,
			"user_id", u.ID(),
			"error", err,
			"critical", isCritical,
		)

		result := &SaveUserResult{Success: false, Error: err}

		if isCritical {
			return result, fmt.Errorf("failed to %s: %w", operation, err)
		}

		h.logger.Warnw(
			"non-critical save operation failed, continuing execution",
			"operation", operation,
			"user_id", u.ID(),
		)
		return result, nil
	}

	h.logger.Infow("user saved successfully", "operation", operation, "user_id", u.ID())
	return &SaveUserResult{Success: true, Error: nil}, nil
}

// RecordFailedLoginAndSave records a failed login attempt and persists the user state
// This is always a non-critical operation to avoid information leakage
func (h *AuthHelper) RecordFailedLoginAndSave(ctx context.Context, u *user.User) *SaveUserResult {
	if u == nil {
		err := fmt.Errorf("user cannot be nil")
		h.logger.Errorw("record failed login: nil user")
		return &SaveUserResult{Success: false, Error: err}
	}

	u.RecordFailedLogin()

	if err := h.userRepo.Update(ctx, u); err != nil {
		h.logger.Errorw("failed to save user after recording failed login", "user_id", u.ID(), "error", err)
		return &SaveUserResult{Success: false, Error: err}
	}

	h.logger.Infow("failed login recorded and saved", "user_id", u.ID())
	return &SaveUserResult{Success: true, Error: nil}
}

// SaveUserAfterSuccessfulLogin saves user state after successful authentication
// This is a non-critical operation - we don't want to fail the login if this save fails
func (h *AuthHelper) SaveUserAfterSuccessfulLogin(ctx context.Context, u *user.User) *SaveUserResult {
	result, _ := h.SaveUserWithLogging(ctx, u, false, "update user after successful login")
	return result
}
